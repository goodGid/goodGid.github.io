---
layout: post
title:  " 동적 라이브러리와 정적 라이브러리 "
categories: Technology
author: goodGid
---
* content
{:toc}

## 라이브러리란?

* 라이브러리(영어: library)는 소프트웨어를 만들 때 쓰이는 클래스나 서브루틴들의 모임을 가리키는 말이다.

* 라이브러리(library)는 다른 프로그램들과 링크되기 위하여 존재하는, 하나 이상의 서브루틴(subroutine)이나 함수(function)들의 집합 파일이다.

* 링크(link)될 수 있도록 보통 **컴파일된 형태**인 **목적 코드(object code)형태**로 존재한다.

* 미리 컴파일 되어 있어서 컴파일 시간도 단축된다.










---

## 라이브러리 사용 목적

* 라이브러리는 코드 재사용을 위해 조직화된 초창기 방법 중의 하나이며 <br> 많은 다른 프로그램들에서 사용할 수 있도록 운영체계나 소프트웨어 개발 환경제공자들에 의해 제공되는 경우가 많다. 

* 라이브러리 내에 있는 루틴들은 범용적으로 사용도 가능하며 <br> 3차원 애니메이션 그래픽 등과 같이 특별한 용도의 함수로 설계 될 수도 있다. 

* 라이브러리들은 사용자의 프로그램과 링크되어 실행이 가능한 완전한 프로그램을 이룬다.

---

## 라이브러리의 구분

* 동적 라이브러리 : 완성된 프로그램을 **실행할 때** 포함시키는 **동적 라이브러리**

* 정적 라이브러리 : 프로그램을 **컴파일하는 과정**에서 포함시키는 **오브젝트 파일들**의 모임

---

## 확장자별 라이브러리 구분 

* .a   : 리눅스  / 정적 라이브러리

* .so  : 리눅스  / 동적 라이브러리

* .lib  : 윈도우  / 정적 라이브러리

* .dll  : 윈도우  / 동적 라이브러리

---


## 동적 라이브러리(Dynamin Library)

* DLL을 구현하고 컴파일하고 나면 Static library와는 다르게 output file이 2개가 생성된다.

* 하나는 *.lib 파일이고 <br> 하나는 *.dll 파일이다.

* 여기서 *.lib 파일은 Static library의 *.lib 파일과는 전혀 다르다.

* Static library의 *.lib 파일은 **라이브러리 전체 코드**를 포함하는 **바이너리**이며, <br> DLL의 *.lib 파일은 DLL이 제공하고자 하는 **함수 정보(함수명)**을 가지는 **정보 파일**이다.

* 프로그램 시작할 때 같이 로딩되어  <br> 프로그램 종료 할 때 **메모리**에서 **해제**되는 방법을 <br> **암시적 링킹(Implicit Linking)**이라 한다.

* DLL의 *.lib 파일을 이용하여 **링킹**하는 것을 **암시적 링킹(implicit linking)**이라고 한다.

* 프로그램 실행 시 필요시만 외부 DLL 파일에서 함수를 참조한다.

* 실행 바이너리를 링크 단계에서 실행 바이너리의 *.obj 파일들과 DLL의 *.lib 파일을 함께 링크하여 <br> 이 정보를 토대로 runtime에 DLL의 함수 코드를 참조하게 되는 것이다.

* 즉 *.lib 파일은 **링크**시 필요하고, *.dll 파일은 **실행**시 필요하다.



---

### 장점

* 메모리를 절약하고 스와핑을 줄인다.

* 프로그램이 **한번 메모리**에 **올려진 것**을 **공유**하므로 메모리 사용 공간이 정적 라이브러리에 비해 적다.

* 여러 프로세스가 메모리에 있는 하나의 DLL 복사본을 공유하여 **하나의 DLL**을 **동시**에 **사용**할 수 있다. 

* 반면, 정적 연결 라이브러리를 사용하여 빌드된 응용 프로그램의 경우 Windows는 각 응용 프로그램에 대해 하나의 라이브러리 코드 복사본을 메모리에 로드해야 한다.

* 동적은 메모리에 올라와있는 DLL을 참조하여 사용하기 때문에 1개만 있으면 되지만 <br> 정적은 빌드 시 라이브러리를 함께 컴파일이 이뤄져야하기 때문에 각 프로그램마다 라이브러리 코드를 갖고있는다.

* DLL을 보다 **쉽게 업그레이드** 할 수 있다. 

* DLL의 **함수**가 **변경**되어도 이 함수의 인수 및 반환 값이 변경되지 않았으면 그 함수를 사용하는 응용 프로그램은 **다시 컴파일**하거나 **링크**할 필요가 없다. 

* 반면, **정적**으로 링크되는 개체 코드의 경우에는 함수가 변경되면 **응용 프로그램**을 **다시 링크**시켜야 한다.

* 출시 후 지원이 가능하다. <br> 예를 들어, 응용 프로그램을 출시할 때 사용할 수 없었던 디스플레이 기능을 지원하도록 디스플레이 드라이버 DLL을 수정할 수 있다.

* **언어 형식**이 **다른 여러 프로그램**을 **지원**한다. 

* 서로 다른 프로그래밍 언어로 작성된 프로그램인 경우에도 **함수의 호출 규칙**을 따르기만 하면 **여러 프로그램**에서 **동일한 DLL 함수**를 호출 할 수 있다. 

* 이 경우 각 프로그램과 DLL 함수는 여러 가지 면(스택에 해당 함수의 인수가 들어가는 순서, 스택을 정리하는 것이 함수인지 응용 프로그램인지의 여부 및 인수가 레지스터에 전달되는지의 여부)에서 호환 될 수 있어야 한다.

* **프로그램 변경시** **변경된 부분**의 **공유 라이브러리**만 **재배포**하면 되므로 유지보수가 쉽다. 

---

### 단점

* **외부 의존도**가 생기기 때문에 **이식성**이 어렵다.

* **공유 라이브러리**를 **메모리**에 올리려면 찾고 올리는데 시간이 걸리므로 성능저하가 생긴다.

---

## 정적 라이브러리(Static Libray)

* 프로그램 빌드 시에 라이브러리가 제공하는 코드를 실행 파일에 넣는 방식의 라이브러리를 의미한다.

* **컴파일**의 **링킹 단계**에서 **실행 파일**에 **결합**된다.

* 특정 기능의 라이브러리를 static 하게 제작한다는 것은 컴파일의 link 단계에서 **라이브러리(*.lib 파일)**를 **실행 바이너리**에 포함시킨다는 얘기이다.

* 즉 **라이브러리의 동작 코드**가 이를 사용하는 **실행 바이너리** 속에 포함되기 때문에 별도의 추가 작업없이, 그리고 **독립적**으로 라이브러리 함수들을 사용할 수 있다.

* 정적 라이브러리를 사용하여 컴파일을 하면 **링커**가 프로그램이 **필요**로 하는 **부분**을 **라이브러리**에서 찾아 실행파일에 바로 **복사**한다. 

* 실행 파일에 다 들어가기 때문에 **실행 시** 라이브러리가 필요없다. 


---

### 장점

* 시스템 환경이 변해도 애플리케이션에 아무런 영향이 없고, **완성된 애플리케이션**을 **안정적**으로 사용할 수 있다.

* **컴파일시** 필요한 라이브러리를 프로그램 내에 적재하기 때문에 **이식성**이 좋다.

* **런타임시** 외부를 참조할 필요가 없기 때문에 **속도**에서 장점이 있다.

---

### 단점

* 같은 코드를 가진 여러 프로그램을 실행할 경우 코드가 중복이 되니 그만큼 메모리를 낭비하게 된다.

* **라이브러리 변경**이 필요할 시, 변경된 라이브러리만 재배포하면 안되고 **프로그램**을 다시 **재배포** 해야 한다.         




---

## Reference

* [동적 라이브러리란?](http://cillic.tistory.com/5)


* [정적 라이브러리와 동적 라이브러리(Static Library, Dynamic Library)](https://m.blog.naver.com/PostView.nhn?blogId=kr_dukie27&logNo=10175747579&proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F)

* [정적 라이브러리(Static library) vs 동적 라이브러리(Dynamic library)](http://luyin.tistory.com/201)

* [DLL과 LIB 차이점 설명](http://it4all.tistory.com/16)

* [정적 라이브러리(Static Library) & 공유 라이브러리(Shared Library)](http://sens.tistory.com/33)