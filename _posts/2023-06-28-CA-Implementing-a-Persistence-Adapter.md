---
layout: post
title:  " [만들면서 배우는 클린 아키텍처] 6장. 영속성 어댑터 구현하기 "
categories: CleanArchitecture
author: goodGid
---
* content
{:toc}

> 이 글은 [책](https://shorturl.at/eoKN3) 내용을 토대로 작성하였습니다.

---

## Prologue

* 책 내용을 다 담을 수 없어

  핵심적인 개념 위주로 정리를 하였으니

  자세한 내용은 책을 봅시다 ! 



---

## 영속성 어댑터의 책임

* 영속성 어댑터의 역할은 다음과 같다.

```
1. 입력을 받는다.
2. 입력을 DB 포맷으로 매핑한다.
3. 입력을 DB로 보낸다.
4. DB 출력을 어플리케이션 포맷으로 매핑한다.
5. 출력을 반환한다.
```

* 여기서 핵심은 

  영속성 어댑터의 입력 모델이

  영속성 어댑터 **내부에 있는 것이 아니라**

  어플리케이션에 있으므로

  영속성 어댑터 내부를 변경하는 것이

  어플리케이션에 영향을 미치치 않는다는 점이다.

---

## 포트 인터페이스 나누기

* Aservice, Bservice가 XxxRepository를 참조하고 있다면?

  각 서비스는 XxxRepository에 1개 메서드만 사용하더라도

  그 외에 필요 없는 메서드에 대한 의존성이 생기게 된다.

* 그러므로 인터페이스 분리 원칙(=ISP(Interface Segregation Principle))을 반영하여

  클라이언트가 오로지 자신이 필요로 하는 메서드만 알 수 있게

  넓은 의미의 인터페이스를 특화된 인터페이스로 분리시키자.

---

## DB 트랜잭션은 어떻게 해야 할까?

* DB 트랜잭션은 유스케이스에 대해서 일어나는

  모든 쓰기 작업에 걸쳐 있어야 한다.

* 그런데 영속성 어댑터는 어떤 DB 연산이

  같은 유스케이스에 포함되는지 알지 못하므로

  언제 트랜잭션을 열고 닫을지 결정할 수 없다.

  그러므로 이 책임은 영속성 어댑터를 호출하는 서비스가 가져야 한다.

* 그래서 @Transactional을 어플리케이션 서비스 클래스에 붙여서 사용하면 된다.

``` java
@Transactional
public class XxxService {
  ...
}
```

---

## Refernece

* [만들면서 배우는 클린 아키텍처](https://shorturl.at/eoKN3)