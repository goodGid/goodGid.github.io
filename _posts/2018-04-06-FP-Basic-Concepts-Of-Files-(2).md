---
layout: post
title:  " 파일의 기본개념 - 파일의 종류  [ Part 2 ] "
categories: 파일처리
author: goodGid
---
* content
{:toc}


# 파일의 연산

* `일괄처리(Batch)` 형식
    - 마스터 파일을 효율적으로 접근하도록 트랜잭션들을 구성
    - `트랜잭션들`을 `그룹화`하여 처리하는 성능이 주요 관심사
    - 모왔다가 한 번에 처리 ! 

* `대화(Interactive` 형식
    - 트랜잭션이 터미널에 도착하는 대로 구성하고 처리
    - `개개 트랜잭션`의 `처리 성능`이 주요 관심사
    - 현재는 대부분이 대화식 !

---

# 파일에 대한 기본 연산

1. 파일 생성 : 데이터 정의

2. 파일 기록 : 레코드 삽입, 삭제, 갱신

3. 파일 판독 : 파일의 이름과 판독해야 할 블록을 명세

4. 파일 삭제 : 파일 제거

5. 파일의 개방과 폐쇄 : 버퍼의 할당과 반환

---

# (1) 생성 (Creation)

* 데이터 수집(Collection)과 확인(Validation)

* `데이터 적재(Loading)`
    - 공간 할당
        - 데이터가 한꺼번에 적재 혹은 한 번에 한 레코드씩 구성
        - 새로운 파일에 대한 엔트리가 디렉토리에 만들어짐


---

# 파일 구조 선정 요소

* `주기억 장치`
    - `최대 비교 연산 횟수`로 평가 <br> --> 빅오 시간복잡도

* `보조 저장 장치`
    - 데이터 접근 시간이 메인 메모리에 비해 얼마나 느린가? <br> 약 pow(10,5)
    - `보조 저장 장치의 접근 회수 (Number of Dist I/O)`가 프로그램 성능 평가 요소
    - ==> `파일 구조 선정의 중요한 요소` // 디스크 접근을 줄이자 ! 


---

# 파일 구조 선정 요소

1. 파일 접근 유형

2. 가변성

3. 활동성

4. 사용빈도수

5. 응답 시간

6. 파일 크기

---

# (1) 파일 접근 유형

* 파일 접근 유형과 파일 구조
    - 연산의 유형과 접근 형식에 다라 파일 구조 결정

---

# (2) 가변성 (Volatility)

* 가변성
    - 전체 레코드 수에 대해 `추가`되거나 `삭제`되는 레코드 수
    - `가변성`이 `높고` `동적`인 `파일`은 <br> 빠르게 접근되고 갱신될 수 있도록 파일을 구성해야 함

---

# (3) 활동성 (Activity)

* 파일의 활동성
    - 주어진 기간 동안에 파일의 총 레코드 수에 대해 `접근`한 레코드 수의 비율
    - 활동성이 높으면 `순차 파일`구조가 좋을 수 있음
    - 얼마나 많은 레코드들을 `검색`하느냐 --> 활동성 <br> 얼마나 많은 레코드들을 `바꾸느`냐 --> 가변성

---

# (4) 사용 빈도수 (Frequency of use)

* 파일의 사용 빈도수
    - 가변성과 활동성에 밀접히 관련
    - 파일 사용이 빈번할수록 파일에 대한 `임의` 접근 필요성은 더욱 높아질 것

---

# (5) 응답 시간 (Response Time)

* 응답 시간과 파일 구조
    - 파일에 대한 접근 방법을 결정하는 데 중요한 요소가 됨
    - 초 단위로 빠른 응답 시간을 필요로 하면 `임의` 접근 방법을 선택해야 됨
    - 순차적으로 정렬된 키에 따라 레코드를 검색한다면 `순차 접근` 방법으로 조직하는 것이 유리

---

# (6) 파일 크기 (File Size)

* 파일 크기와 파일 구조
    - 성장을 유연하게 수용할 수 있는 구조 필요 <br> 일반적으로 30% 추가해서 설계
    - 파일 성장을 유연하게 수용할 수 없을 시 파일을 `재조직(Reorganization`해야 됨


