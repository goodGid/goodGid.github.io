---
layout: post
title:  " Kafka 커밋과 오프셋 (Commit & Offset) "
categories: Kafka
author: goodGid
---
* content
{:toc}

> 이 글의 코드 및 정보들은 [책](https://book.naver.com/bookdb/book_detail.nhn?bid=13540082)을 바탕으로 작성하였습니다.

## Kafka Commit

* 컨슈머가 poll()을 호출할 때마다

* 컨슈머 그룹은 

* 카프카에 저장되어 있는

* 아직 읽지 않은 메시지를 가져온다.

<br>

* 이렇게 동작할 수 있는 것은

* 컨슈머 그룹이

* 메시지를 어디까지 가져갔는지 알고 있기 때문이다.







<br>

* 컨슈머 그룹의 컨슈머들은

* 각각의 파티션에 

* 자신이 가져간 메시지의 위치 **정보(오프셋)**을 기록하고 있다.

<br>

* 그리고 각 파티션에 대해

* 현재 위치를 업데이트하는 동작을 **커밋(Commit)**한다고 한다.

<br>


* 카프카는 

* 각 컨슈머 그룹의 파티션별로

* 오프셋 정보를 저장하기 위한 

* **저장소**가 별도로 필요하다.

<br>

* 이를 위해 [올드 카프카 컨슈머(0.9 이전 버전)]({{site.url}}/Kafka-Consumer-Option/#컨슈머-종류)는 

* 이 오프셋 정보를 

* **주키퍼**에 저장하였지만

* 성능 등의 문제로

* [뉴 컨슈머]({{site.url}}/Kafka-Consumer-Option/#컨슈머-종류)에서는 

* 카프카 내에 별도로 

* 내부에서 사용하는 **토픽(__consumer_offsets)**을 만들고

* 그 토픽에 오프셋 정보를 저장하고 있다.

<br>

* 모든 컨슈머들이 살아있고

* 잘 동작하고 있는 동안에는 아무런 영향이 없다.

<br>

* 만약 컨슈머가 갑자기 다운되거나 

* 컨슈머 그룹에 새로운 컨슈머가 조인한다면

* 컨슈머 그룹 내에서 [리밸런스]({{site.url}}/Kafka-Consumer-Group-Rebalance/)가 일어나게 된다.

<br>


* 리밸런스가 일어난 후 

* 각각의 컨슈머는 이전에 처리했던 토픽의 파티션이 아닌

* 다른 새로운 파티션에 할당된다.

<br>

* 컨슈머는 새로운 파티션에 대해 

* 가장 최근 커밋된 오프셋을 읽고

* 그 이후부터 메시지들을 가져오게 된다.

<br>

* 만약 커밋된 오프셋이 

* 컨슈머가 실제 마지막으로 처리한 오프셋보다 작으면

* 마지막으로 처리된 오프셋과 

* 커밋된 오프셋 사이의 메시지는 중복으로 처리되고

* 커밋된 오프셋이 

* 컨슈머가 실제 마지막으로 처리한 오프셋보다 크면

* 마지막으로 처리된 오프셋과 

* 커밋된 오프셋 사이의 모든 메시지는 누락된다.

<br>

* 이렇게 커밋은 매우 중요하며

* 카프카에서는 여러 가지 방법을 제공해준다.

1. [자동 커밋]({{site.url}}/Kafka-Commit-Type-Auto-Commit/)

2. [수동 커밋]({{site.url}}/Kafka-Commit-Type-Manual-Commit/)

---

## Reference

* [카프카, 데이터 플랫폼의 최강자 실시간 비동기 스트리밍 솔루션 카프카의 기본부터 확장 응용까지](https://book.naver.com/bookdb/book_detail.nhn?bid=13540082)