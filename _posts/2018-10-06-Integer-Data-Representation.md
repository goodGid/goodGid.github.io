---
layout: post
title:  " 정수 데이터 표현 "
categories: Technology
author: goodGid
---
* content
{:toc}

## 정수의 부호

* 첫 번째 비트가 0이면 부호가 없는 정수(0과 양의 정수)

* 첫 번째 비트가 1이면 부호가 있는 정수(음의 정수)

* 부호 및 크기 방식, 1진 보수 방식, 2진 보수 방식에 따라 표현하는 방법이 다르다.











---

### 양의 정수

* 첫 번째 비트는 0

* 나머지 비트는 **크기**이다. <br> 예) 01001010 <br> 맨 앞의 0은 부호, 1001010은 크기 <br> 이진수 1001010 = 2의 6승 + 2의 3승 + 2의 1승 = 64 + 8 + 2 = 74

---

### 음의 정수

* 첫 번째 비트는 1

---

## 부호 및 크기 방식(Signed Magnitude)

* 부호 비트를 제외한 나머지 비트는 크기를 나타낸다. <br> 예) 11001010 <br> 맨 앞의 1은 부호, 1001010은 크기 <br> 이진수 1001010 = 2의 6승 + 2의 3승 + 2의 1승 = 64 + 8 + 2 = 74 <br> 따라서 -74

* 단점
    - 10,000,000은 크기가 0이고 부호가 있는 -0이다. 
    - 따라서 +0(=00,000,000) 과 -0(10,000,000) 두 가지 0이 존재한다.

---

## 1진 보수(Signed 1’s Complement)

* 부호 비트를 제외한 나머지 비트를 **1진 보수**를 취한 값이 크기를 나타낸다. <br> 예) 11001010 <br> 맨 앞의 1은 부호, 1001010의 1진 보수는 크기 <br> 1진 보수를 취할 때는 0은 1로 1은 0으로 변환한다. <br> 따라서 이진수 1001010의 1진 보수는 0110101이다. <br> 이진수 0110101 = 2의 5승 + 2의 4승 + 2의 2승 + 2의 0승 = 32 + 16 + 4 + 1 = 53 <br> 따라서 -53

* 단점
    - 11,111,111의 맨 앞의 1은 부호, 1,111,111의 1진 보수는 0,000,000이어서 크기가 0
    - 따라서 +0(=00,000,000)과 -0(= 11,111,111) 두 가지 0이 존재한다.

* 연산 방법
    - 자리올림이 발생하면 결과에 **자리올림한 수**를 더한다.
    - 예: 01110011 + 11000101은 아래 그림처럼 연산하여 00111001이 된다.

![](/assets/img/posts/integer_data_representation_1.png)


---

## 2진 보수(Signed 2’s Complement)

* 부호 비트를 제외한 나머지 비트를 **2진 보수**를 취한 값이 크기를 나타낸다. <br> 예) 11001010 <br> 맨 앞의 1은 부호, 1001010의 2진 보수는 크기 <br> 2진 보수를 취할 때는 1진 보수를 취한 후에 1을 더한다. <br> 따라서 이진수 1001010의 1진 보수는 0110101이고, 여기에 +1을 하여 2진 보수는 0110110이 된다. <br> 이진수 0110110 = 2의 5승 + 2의 4승 + 2의 2승 + 2의 1승 = 32 + 16 + 4 + 2 = 54 <br> 따라서 -54

* 장점
    - 0이 한 가지만 존재한다.

* 연산방법
    - 자리올림이 발생한 것을 **무시**한다.
    - 예: 01110011 + 11000101 은 아래 그림처럼 연산하여 00111000이다.

![](/assets/img/posts/integer_data_representation_2.png)



---

## Reference

* [[algorithm] 어떤 정렬 알고리즘이 대부분 정렬 된 데이터에서 가장 잘 작동합니까?](https://code.i-harness.com/ko-kr/q/35b8c)