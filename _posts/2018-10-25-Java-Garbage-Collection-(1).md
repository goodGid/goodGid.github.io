---
layout: post
title:  " 가비지 컬렉션(Garbage Collection) 1편"
categories: Java
tags: Java
author: goodGid
---
* content
{:toc}

## GC란?

* 쓰레기 수집(garbage collection, GC)은 **[메모리 관리 기법]({{site.url}}/Java-Garbage-Collection-(1)/#메모리-관리)** 중의 하나이다.

* 프로그램이 **동적**으로 할당했던 메모리 영역 중에서 필요없게 된 영역을 **해제**하는 기능이다. 








---


## GC 장단점

### 장점

* GC를 지원하는 환경에서는 프로그래머가 **동적**으로 **할당한 메모리 영역**의 전체를 완벽하게 **관리할 필요**가 없어진다. 

* 쓰레기 수집은 다음과 같은 **버그**를 줄이거나 완전히 막을 수 있다.
    - 유효하지 않은 포인터 접근 
        - 이미 **해제된 메모리**에 **접근**하는 버그를 가리킨다. 
        - 만약 이 포인터가 해제되고 새로운 값이 할당되었다면, 잘못된 값을 읽어오게 된다.
    - 이중 해제 
        - 이미 **해제된 메모리**를 **다시 해제**하는 버그를 가리킨다. 
        - 일부 메모리 할당 알고리즘에서는 해제된 메모리를 다시 해제하려고 시도하는 오류를 일으킬 수 있다.
    - [메모리 누수]({{site.url}}/Java-Garbage-Collection-(1)/#메모리-누수)
        - 더이상 **필요하지 않은 메모리**가 해제되지 않고 남아있는 버그를 가리킨다. 
        - 메모리 누수가 반복되면 메모리 고갈로 프로그램이 중단될 수 있다. 
        - 접근 가능한 메모리가 증가하여 메모리가 고갈되는 문제는 쓰레기 수집으로도 막을 수 없다.


### 단점

* 어떤 메모리를 해제할지 결정하는 데 **비용**이 든다. 

* 객체가 필요없어지는 시점을 프로그래머가 미리 알고 있는 경우에도 <br> GC 알고리즘이 메모리 해제 시점을 추적해야 하므로 이 작업은 **오버헤드**가 발생된다.

* 쓰레기 수집이 일어나는 **타이밍**이나 **점유 시간**을 미리 예측하기 어렵다. <br> 즉 할당된 메모리가 해제되는 시점을 알 수 없다. 

* 때문에 프로그램이 **예측 불가능**하게 일시적으로 **정지**할 수 있다. 

* 이런 특성은 특히 **실시간 시스템**에는 적합하지 않다.


---

## JVM 메모리 구조

* 아래 사진은 **자바(JVM)의 메모리 구조**이다. 

* 크게 **Heap / Perm / Thread**로 나눌 수 있다.

* Heap은 다시 **Young(New) 영역**과 **Old 영역**으로

* Young 영역은 다시 **Eden / Survior1 / Survior2**로 나눌 수 있다.

<br>

* Young 영역은 객체가 처음 생성 시 저장되는 영역을 나타낸다.

* 정확하게 말하면 new연산자를 통해 생성되는 객체들은 **EdenSpace**에 저장된다.

* Old 영역은 **Young 영역에 존재하던 객체들**이 **오래되어 저장**되는 영역이다.

* Perm영역은 Class 혹은 method코드가 저장되는 영역으로 JVM에 의해서 된다.



![](/assets/img/java/java_garbage_collection_1_1.png)


---

## GC의 종류

* Java의 GC는 크게 두 가지로 Minor GC와 Full GC로 나눌 수 있다.

* 그 중 Minor GC는 Young 영역에 발생하는 GC를 나타낸다. 

* 자세한 내용은 [가비지 컬렉션(Garbage Collection) 2편]({{site.url}}/Java-Garbage-Collection-(2))에서 알아보자.

### Minor GC

* Young 영역에서 돌아가는 GC라고 생각하면 된다.

1. 처음 Minor GC가 발생하기 전 할당 되어있는 모든 객체들은 Eden 영역에만 존재한다.

2. 이때 Minor GC가 발생하면 Eden 영역 중 활성 객체가 Survivor1영역으로 이동한다. <br> 이 후 비활성 객체만 남은 Eden 영역이 클리어된다.

3. 다음 Minor GC가 발생하면 <br> 처음 Minor GC 이후 생성된 객체들이 존재하는 Eden 영역의 객체들과 <br> 처음 Minor GC 이후 생존한 객체들이 저장된 Survivor1의 영역 객체들이 <br> **Survivor2로 이동**하고 Eden 영역과 Survivor1영역이 클리어 된다.

4. 이 후 위 작업이 Survivor1과 Survivor2를 번갈아가면서 계속 수행되고 <br> 계속해서 활성 객체로 생존하는 객체들은 시간이 지남에 따라 Old 영역으로 이동한다.

![](/assets/img/java/java_garbage_collection_1_2.png)


### Full GC

* Old 영역에서 돌아가는 GC라고 생각하면 된다.

* Full GC는 Old 영역이 Full이 되면 수행된다.

* Full GC는 Old 영역을 스캔하여 객체들의 참조 상태를 표시하고 <br> **참조되지 않는 객체**를 **해제(Mark&Compact)**하는 작업을 실시한다.

* 이러한 Full GC는 속도가 느리고 성능에 아주 큰 영향을 끼친다. 

* 이유는 Full GC가 수행되는 동안 자바 애플리케이션은 **멈춤 현상**이 발생하기 때문이다.


---

## 포인터 추적 방식

* 대부분의 쓰레기 수집 기법은 **포인터 추적 방식**을 사용한다. 

* 포인터 추적 방식은 **한 개 이상의 변수**가 **접근 가능한 메모리**는 앞으로 사용할 수 있는 메모리로 간주하고 <br> **그 밖의 메모리**를 **해제**하는 방식을 가리킨다.

### 접근 가능한 객체

* **접근 가능한 객체**는 어떤 변수가 직접 가리키는 메모리 또는 간접적으로 가리키는 메모리를 의미한다. 


### 여러가지 포인터 추적 기법

* 포인터 추적 기법에는 **여러가지 방법**이 존재한다. 

* 어떤 언어들은 다음 기법들 가운데 여러가지를 함께 사용하기도 한다.

> 표시하고 쓸기 (mark and sweep)

* 표시하고 쓸기 기법은 포인터 추적 기법 가운데 **가장 단순**한 기법이다. 

* 먼저 각 메모리 할당 영역에 표시를 위해 **1 비트의 메모리**를 남겨 둔다. 

* **표시 단계**에서 모든 변수가 가리키는 영역을 **사용 중**으로 표시하고 <br> 그 영역에서 가리키는 또다른 영역 또한 **사용 중**으로 표시한다. 

* 이와 같이 모든 메모리 영역을 표시하고 나면, 표시되지 않은 영역을 **접근 불가능한 메모리 영역**이 된다. 

* 접근 불가능한 메모리 영역들은 **쓸기 단계**에서 모두 해제한다.

* 이 기법의 **단점**은, 표시 단계에서 메모리 내용이 변경되지 않아야 하기 때문에 **전체 시스템의 실행이 정지**된다는 것이다. 

* 또한 전체 메모리 영역을 검사해야 하므로 메모리 페이징을 사용하는 운영체제에서 프로그램의 성능이 저하될 수 있다.

> 삼색 표시 기법

* *표시하고 쓸기 기법* 의 **단점**을 보완하기 위해 **많은 언어들**은 **삼색 표시 기법**을 사용한다. 

* 삼색 표시 기법은 기본적으로 *표시하고 쓸기* 와 같은 기법이지만 <br> 표시 단계에서 2가지가 아닌 **3가지(흰색, 회색, 검은색) 정보** 중 하나로 메모리를 표시한다.

* 이 기법은 다음과 같은 순서로 이루어진다.

1. 각각의 객체를 흰색, 회색, 검은색으로 분류한다. <br> 흰색은 **더이상 접근 불가능한 객체**를 가리킨다. <br> 회색은 **접근 가능한 객체**이지만, **이 객체에서 가리키는 객체들**은 **아직 검사되지 않았음**을 의미한다. <br> 검은색은 이 영역에서 가리키는 객체들이 **흰색 객체를 가리키지 않음**을 의미한다.

2. 알고리즘이 **시작할 때**는 **변수가 가리키는 객체들**이 **회색**으로 표시되며, **그 외의 모든 객체**는 **흰색**으로 표시된다.

3. **회색**으로 표시된 **객체 가운데 하나**를 선택하여 **검은색으로 표시**하고, **이 객체가 가리키는 모든 객체**를 **회색**으로 표시한다.

4. 회색 객체가 하나도 남지 않을 때까지 위 과정을 반복한다.

5. 남은 흰색 객체는 접근 불가능한 객체이므로 모두 해제한다.

* 이 알고리즘은 단순한 *표시하고 쓸기 알고리즘* 과 달리 프로그램이 실행 중에도 **병행**하여 **수행**할 수 있다. 

* 또한, 메모리가 고갈되었을 때 쓰레기 수집을 실행하는 것이 아니라 **주기적**으로 **수집**하는 것도 가능하다.

> 객체 이동 기법

* 객체 이동 기법은 **해제되지 않은 객체**를 그대로 두는 것이 아니라 **다른 영역**으로 **복사하는 기법**을 가리킨다. 

* 원래대로 유지해도 무방한 객체를 복사하는 것은 언뜻 비효율적으로 여겨질 수도 있으나 <br> 다음과 같은 **실용적인 장점**을 가지고 있다.
    - 해제된 후 재사용 가능한 영역과 사용 중인 영역을 표시하기 위해 추가적인 작업을 할 필요가 없다. <br> <small> 뇌피셜 :: 새로운 곳에서 빈 공간은 무조건 사용가능하기 때문이지 않을까? </small>
    - 따라서 해제된 영역을 포인터로 관리하는 방식에 비해 할당과 해제가 빠르게 이루어진다.

* 할당된 메모리들이 **단편화**되는 것을 막을 수 있다.

* 연결 리스트와 같은 **연결형 자료구조**에서 **서로 연결된 객체들**이 메모리 상에서 가까운 위치에 할당될 확률이 높아진다. <br> 이는 **캐시**와 관련하여 성능 향상에 도움이 된다.

* 반면, 메모리 이동 기법은 **주기적으로 포인터의 내용**이 바뀌므로 포인터 연산을 사용할 수 없게 된다는 단점이 있다.

> 세대 단위 쓰레기 수집

* 많은 연구자들은 프로그램에서 **새롭게 할당된 영역**일수록 **금방 해제될 확률**이 높다는 관찰을 보고하였다. 

* 세대 단위 쓰레기 수집 기법은 이런 특성을 이용하여 각각의 객체를 **할당된 시간**에 따라 **세대별로 구분**하여 <br> 각 세대별로 **서로 다른 메모리 영역**에 객체를 할당한다. 

* 만약 한 세대의 메모리 영역이 꽉 차면 이 메모리 영역에서 **살아남은 객체**를 더 **오래된 메모리 영역**으로 옮긴다. 

* **새로 할당된 영역**에서는 대부분의 객체들이 **빠르게 해제**되고 <br> **오래된 영역**에서는 **객체들이 변하지 않을 확률**이 높으므로 <br> 이 기법은 메모리의 일부 영역만을 주기적으로 수집하게 되는 **장점**이 있다. 

* **자바**, 닷넷 프레임워크 등 현대적 언어들은 대부분 이 기법을 사용한다.



---


## 메모리 관리

* 메모리 관리는 **컴퓨터 메모리를 관리**하는 행위이다. 

* 가장 단순한 형태의 메모리 관리 방법은 <br> 프로그램의 요청이 있을 때 **메모리의 일부**를 **해당 프로그램에 할당**하고 <br> 더 이상 **필요하지 않을 때** 나중에 다시 사용할 수 있도록 **할당**을 **해제**하는 것이다. 

* 이는 **하나 이상의 프로세스**가 언제든 **실행**되는 고급 컴퓨터 시스템에 필수적이다.

* **가상 메모리 시스템**은 프로세스가 사용하는 메모리 주소를 **실제 물리 주소**와 **구분**한다. 

* 이로써 프로세스를 구분하고 **디스크 스왑 처리**를 사용하여 효과적으로 사용할 수 있는 램의 양을 늘릴 수 있게 된다. 

* 가상 메모리 관리자의 품질은 전반적인 시스템 성능에 큰 영향을 미친다.

* 쓰레기 수집은 **프로그램을 위한 컴퓨터 메모리 리소스**를 자동으로 할당하고 할당을 해제한다. 

* 프로그래밍 언어 수준에서 일반적으로 추가되어 있는 것이며 수동 메모리 관리와 대조된다.



---


## 메모리 누수

* 메모리 누수(memory leak) 현상은 컴퓨터 프로그램이 **필요하지 않은 메모리**를 **계속 점유**하고 있는 현상이다. 

* 할당된 메모리를 사용한 다음 **반환하지 않는 것**이 **누적**되면 메모리가 낭비된다. 



---

## 참고

* [쓰레기 수집 (컴퓨터 과학)](https://ko.wikipedia.org/wiki/%EC%93%B0%EB%A0%88%EA%B8%B0_%EC%88%98%EC%A7%91_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99))

* [메모리 관리](https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EA%B4%80%EB%A6%AC)

* [메모리 누수](https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EB%88%84%EC%88%98)

* [JAVA - Garbage Collection(가비지 컬렉션)](http://mllab.tistory.com/329)

* [Java Garbage Collection](https://d2.naver.com/helloworld/1329)
