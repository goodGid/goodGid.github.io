---
layout: post
title:  " 동시 멀티스레딩(SMT, Simultaneous Multi-Threading) "
categories: OS
tags: OS
author: goodGid
---
* content
{:toc}

## 동시 멀티스레딩(SMT, Simultaneous Multi-Threading)이란? 

* **SMT**라는 명칭은 동시 멀티스레딩을 뜻하며 학계에서 주로 지칭하는 용어로 사용되고 있다.

* 시장에서는 인텔이 이 기술을 부르는 이름인 **하이퍼쓰레딩**으로 더 유명하지만 <br> 이 기술이 인텔 독점인 것은 아니며 <br> AMD에서도 기존의 불도저에 적용한 CMT(Cluster Multi-Threading) 구조를 버리고 <br> 2017년 3월 초에 출시된 RYZEN에 이 구조를 채용하면서 사실상 거의 모든 데스크탑 CPU에 적용되는 기술이 되었다. 










---

## 원리

* 단일 코어에서 구현할 수 있는 명령어 수준의 **병렬처리 능력(Instruction-Level Parallelism)**은 <br> **명령어 종속성(Dependency)**으로 인해 구현에 한계가 있다. 

* RAW(Read-After-Write), WAR(Write-After-Read), WAW(Write-After-Write) 등의 다양한 종속성이 있으며 <br> 일부는 구조적으로 극복할 수 있다고 해도 근본적인 종속은 해결되지 않는다. 

* 그렇다면 이를 증가시킬 수 없다면 **남는 연산 능력**을 다른 스레드의 명령어를 처리하는데 사용한다면 <br> 양 스레드간의 명령어 종속성은 거의 없을 것이기에 <br> 단일 코어에서 전체적인 명령어 병렬 처리 능력을 증가시킬 수 있다는 개념의 기술이다. 

* 현대의 CPU는 슈퍼스칼라 구조와 파이프라이닝 기법이라고 해서 <br> CPU 전체가 한 번에 하나의 명령을 처리하는 것이 아니라 <br> 명령어 몇 개를 동시에 처리함과 동시에 <br> 명령 하나를 또다시 여러 단계의 작은 명령으로 나누고 각 부분을 차례대로 처리한다. 

* 즉 몇 개의 명령어가 몇분의 1로 나누어지고, 그런 명령어 몇 개가 한번에 돌아가는 것이다.

* 이런 식으로 작동하는 이유는 많은 기계어 명령이 코드로는 하나로 되어 있어도 <br> 실제 처리해야 하는 일은 여러 단계로 나누어져 있고 <br> 각 단계는 이전 단계가 처리되기 전에는 수행이 불가능하기 때문이다. 

* 예를 들어 메모리의 값을 증가시키는 명령이 다음과 같이 작동한다면 <br> 1번이 끝나기 전에는 2번을 할 수 없고 2번이 끝나기 전에는 3번을 할 수 없다.

```
1. 메모리의 값을 읽는다.
2. 읽은 값을 더한다.
3. 값을 메모리에 쓴다.
```

* 그런데 실제로는 명령이 처리되기 위해 필요한 일이 명령마다 다르다.

* CPU의 예시는 아니지만 네트워크 비동기 처리의 예시를 들어보자. 

```
1. 네트워크의 값을 읽는다.
2. 읽은 값을 처리한다.
3. 값을 저장장치에 쓴다.
```

* 네트워크에서 특정 값을 읽어 이를 처리하는 경우 상당한 경우에는 <br> 네트워크의 대기 시간이 프로그램 전체 실행 시간의 대부분을 차지한다. 

* 이 상황에서 위와 같이 코드를 작성한다면 <br> 1번의 네트워크 대기 지연 시간에 의해 프로그램은 상당히 비효율적인 구조를 가지게 될 것이다. 

* 네트워크에서 값을 읽어오는 데 걸리는 시간은 <br> 시스템의 자체 저장장치인 메모리나 하드디스크에서 데이터를 읽는데 걸리는 시간에 비해 몇십~몇천배는 되기 때문이다. 

* 이 때 CPU는 1번에서 값을 읽어올 때까지 대기하게 된다.

* 하지만 CPU가 처리해야 할 일 중에는 이렇게 서로 연계된 일만 있는 게 아니다. 

* 예를 들어 네트워크에서 값이 들어오길 하염없이 기다리는 저 컴퓨터에서 동시에 MP3 파일도 하나 재생하고 있다고 하자. 

* 그렇다면 네트워크에서 값이 들어올 때까지 MP3을 재생하고 있으면 효율이 올라가지 않을까? 

* **하이퍼스레딩**은 이렇게 **놀고 있는 부분에** <br> **명령어 종속성이 없는 다른 스레드의 명령어**를 투입하여 <br> **CPU의 효율**을 높이는 일종의 우회책이다. 

* **CPU의 최대 성능 이상**은 절대 낼 수 없지만 <br> 프로그램의 한계 때문에 쓰지 못했던 **CPU의 남은 성능**을 끝까지 쥐어짜는 셈이다.

* 즉 S/W의 관점으로는 하나의 코어에 하나의 가상의 코어를 만들어서 **CPU 2개**로 인식된다. 

* 기본적으로 별개의 명령을 처리해야 하기 때문이다. 

* 그래서 **HT(=하이퍼쓰레딩)**가 지원되는 CPU를 작업 관리자에서 보면 코어 수가 2배로 뻥튀기 되는 것을 알 수 있다.

![](/assets/img/os/simultaneous_multi_threading_1.png)

---

## SMT 예시

* 1과 2라는 프로세스(쓰레드)에서 명령을 처리할 때 하이퍼스레딩의 유무에 따른 CPU의 상태를 살펴보자.

> 하이퍼스레딩이 없는 CPU 

* `<int>`는 다른 프로세스로 전환을 의미한다.

```
1 <init>
1
1
1 
2 <init>
2 
1
1 
2 <end>
1 <end>
```
* 이런 식으로 한번에 하나의 명령만 처리 할 수 있다. 

* 두 개의 작업을 재빠르게 전환하는 **[멀티 태스킹]({{site.url}}/OS-Start-From-Multi/#멀티-태스킹multi-tasking)**이다.

* 하지만 하이퍼스레딩을 사용한다면 **[멀티 프로그래밍]({{site.url}}/OS-Start-From-Multi/#멀티-프로그래밍multi-programming)**이라고 할 수 있다.

> 하이퍼스레딩이 있는 CPU 

```
1,(2)
1,(2)
1,(2)
1,(2)
1.(2)
1,(2)
1 <end>
2 <end>
```

* 이런 식으로 처리할 내용을 우겨 넣어서 성능을 향상 시키는 원리다.

* 물론 **2개의 물리적인 코어**보다는 **성능**이 확실히 떨어진다. 

* 이 논리로 하이퍼스레딩이 있어봤자 느리다고 하지만 <br> 그래도 단일 코어 환경에 비하면 <br> 상대적으로 다른 프로세스에 훨씬 많은 여유를 줄 수 있는 장점이 있다. 

* 예를 들어 3D 렌더링을 할 경우 진가가 들어나는데 <br> 3D 렌더러는 쓰레드 당 한 개의 렌더링 블록을 생성해 내는데, <br>하이퍼스레딩이 켜진 쿼드 코어 CPU의 경우 <br> 8개의 스레드가 생성되어(즉 논리적인 옥타코어) 시간의 이점을 볼 수 있다. (20% 정도 차이가 난다)

---

## 참고

* [SMT](https://namu.wiki/w/SMT)
