---
layout: post
title:  " 흐름 / 혼잡 / 오류 제어 기법 "
categories: Network
author: goodGid
---
* content
{:toc}


## To Do

* TCP의 가장 큰 특징은 신뢰성이다. <br> 이러한 신뢰성을 구성해 주는 방법인 **흐름제어**, **혼잡제어**, **오류제어**에 대해 알아보자.








---

## 흐름 제어

> 송신(호스트) <> 수신(호스트)

* 흐름제어는 수신측과 송신측의 데이터처리 속도차이를 해결하기 위한 기법이다.

* 만약 송신측의 전송량 > 수신측의 처리량 일 경우, 전송된 패킷은 수신측의 큐를 넘어서 <br> 손실될 수 있기 때문에 송신측의 패킷 전송량을 제어하게 된다.



---

## 흐름제어 방법


### 정지-대기(Stop-and-wait)

![](/assets/img/network/error_flow_control_1.png)

* 구조가 간단한 대신, 하나를 주고 응답을 받기 때문에 비효율적이다.


### 슬라이딩 윈도우(Sliding Window)

* 윈도우는 전송,수신 스테이션 양쪽에서 만들어진 버퍼(Buffer)의 크기다. <br> 윈도우의 크기 = (가장 최근 ACK로 응답한 프레임의 수) - (이전에 ACK 프레임을 보낸 프레임의 수)

* 슬라이딩 윈도우 기법은 앞의 **정지-대기 기법**의 비효율성을 개선한 기법이다.

* ACK프레임을 수신하지 않더라도, 여러 개의 프레임을 연속적으로 전송할 수 있다.


* 전송측 윈도우 n-1 개의 프레임을 포함한다.

![](/assets/img/network/error_flow_control_2.png)


* 위와 같은 구조에서 데이터 0, 1을 전송했다고 가정하면 <br> 슬라이딩 윈도우의 구조는 다음과 같이 변하며 윈도우의 크기는 전송한 데이터 프레임만큼 줄어들게 된다.


![](/assets/img/network/error_flow_control_3.png)


* 이때 만약 수신측에서 ACK라는 프레임을 받게 된다면 전송측은 0, 1이 데이터를 정상적으로 받았음을 알게 되고, <br> 전송측은 ACK 프레임에 따른 프레임의 수만큼 오른쪽으로 경계가 확장된다.


![](/assets/img/network/error_flow_control_4.png)





---



## 혼잡 제어

> 송신(호스트) <> 라우터(네트워크)

* 혼잡 제어는 송신측과 네트워크의 데이터처리 속도 차이를 해결하기 위한 기법이다.

* 송신된 패킷이 네트워크 상의 라우터가 처리할 수 있는 양을 넘어서 혼잡하게 되면 <br> 데이터가 손실될 수 있기 때문에 송신측의 전송량을 제어하게 된다.

---

## 혼잡 제어 종류

### 합 증가/곱 감소

* 이 방식은 AIMD(Additive Increase/Multiplicative Decrease)라고 불리는 방식이다. 

* 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 창 크기(단위 시간 내에 보내는 패킷의 수)를 1씩 증가시켜가면서 전송하는 방법이다. 

* 만일 **패킷 전송**을 **실패**하거나 **일정한 시간**을 넘으면 패킷을 보내는 **속도**를 **절반**으로 줄이게 된다.

* 이 방식은 **공평한 방식**이다. 

* 이 방식을 사용하는 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만 시간이 흐르면 **평형 상태**로 수렴하게 되는 특징이 있다.

* 문제점은 **초기에** **네트워크의 높은 대역폭**을 **사용**하지 못하여 **오랜 시간**이 걸리게 되고,<br> 네트워크가 혼잡해지는 상황을 미리 감지하지는 못한다.

* 즉, **네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식**이다.


---


### 슬로우 스타트(Slow Start)

* **합 증가/곱 감소 방식**이 네트워크의 수용량 주변에서는 효율적으로 작동하지만 <br> 처음에 전송 속도를 올리는 데 걸리는 시간이 너무 길다는 단점이 있다. 

* **느린 시작(Slow Start) 방식**은 합 증가/곱 감소 방식과 마찬가지로 패킷을 하나씩 보내는 것부터 시작하고, <br> 이 방식은 패킷이 문제없이 도착하면 각각의 ACK 패킷마다 Window size를 1씩 늘린다. <br> 즉, 한 주기가 지나면 Window size가 2배로 된다. 

* 따라서 전송 속도는 합 증가/곱 감소와는 다르게 **지수 함수 꼴**로 증가하게 된다. 

* 대신에 **혼잡 현상**이 발생하면 Window size를 1로 떨어뜨리게 된다.

* 처음에는 네트워크의 수용량을 예상할 수 있는 정보가 없지만 <br> 한번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느 정도 예상할 수 있으므로 <br> 혼잡 현상이 발생하였던 Window size의 절반까지는 **이전**처럼 **지수 함수 꼴**로 창 크기를 증가시키고 그 이후부터는 완만하게 1씩 증가시키는 방식이다.


```
1) 초기 혼잡 윈도우 크기 1로 전송 = 전송 호스트는 하나의 패킷만 전송
2) 수신 호스트로부터 수신응답을 수신하면 윈도우의 크기를 2로 하여 전송
3) 수신 호스트로부터 수신응답을 수신하면 윈도우의 크기 4로 하여 전송
4) 수신 호스트로부터 수신응답을 수신하면 윈도우의 크기 8로 하여 전송
```

![](/assets/img/network/error_flow_control_10.png)



* 미리 정해진 임계 값에 도달할 때까지 윈도우의 크기를 2배씩 증가시킨다.

* Slow start란 이름을 사용하지만, 매 전송마다 두 배씩 증가하기 때문에 전송되어지는 데이터의 크기는 지수 함수적으로 증가한다.

* 전송되어지는 데이터의 크기가 임계 값에 도달하면 **혼잡 회피** 단계로 넘어간다.


---

### 혼잡 회피(Congestion Avoidance) 

* 윈도우의 크기가 임계 값에 도달한 이후에 데이터의 손실이 발생할 확률이 높아지게된다.

* 데이터를 전송함에 있어서 조심하는 단계이다.

```
전송한 데이터에 대한 Ack를 받으면 윈도우의 크기를 1씩 증가시킨다.
전송하는 데이터의 증가를 왕복시간 동안에 하나씩만 증가시킨다.
```
* 수신 호스트로부터 일정 시간 동안까지 Ack를 수신하지 못하는 경우
    - 타임아웃의 발생 : 네트워크에 혼잡이 발생하였다고 인식
    - 혼잡상태로 인식된 경우
        - 윈도우의 크기를, 즉 세그먼트의 수를 1로 줄임
        - 동시에 임계 값을 패킷 손실이 발생하였을 때의 윈도우 크기의 반으로 줄임




---

### 빠른 회복(Fast Recovery)

* 빠른 회복 정책은 혼잡한 상태가 되면 Window size를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방법이다.

* 빠른 회복 정책까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 **합 증가/곱 감소 방식**으로 동작하게 된다.


---

## 오류 제어

* **오류 제어 기법**은 **오류검출(error detection)**과 **재전송(retransmisstion)**을 포함한다.

* **ARQ(Automatic Repeat Request)**기법을 사용하여 프레임이 손상되었거나 손실되었을 경우 재전송을 통해 오류를 복구한다.

* ARQ기법은 흐름제어 기법과 관련되어있는데, <br> "정지-대기"는 정지-대기-ARQ로, <br> "슬라이딩 윈도우"는 GBn(Go-Back-n) ARQ 또는 SR(Selective-Reject) ARQ 형태로 구현한다.


---

## 오류 제어 종류 

> ARQ(Automatic Repeat Request) : 신뢰성 있는 데이터 전달을 위해 재전송을 기반으로 한 에러 제어 방식

### 정지-대기 ARQ

* 전송스테이션은 수신측에서 보내준 ACK를 받을 때 까지, 프레임의 복사본을 유지한다.

* 식별을 위해 데이터 프레임과 ACK프레임은 각각 0, 1번호를 부여한다.

* 수신측이 데이터를 받지 못했을 경우, NAK를 보내고, NAK를 받은 송신측은 데이터를 재전송한다.

* 만약 데이터나 ACK가 분실되었을 경우 일정간격의 시간을 두고 타임아웃이 되면, 송신측은 데이터를 재전송한다.

![](/assets/img/network/error_flow_control_5.png)


---


### Go-Back-n ARQ (GBn ARQ)

* 전송된 프레임이 손상되거나 분실될 경우, 확인된 마지막 프레임 이후로 모두 재전송 하는 기법이다.

* 슬라이딩 윈도우는 연속적인 프레임 전송 기법이므로, <br> 전송 스테이션은 전송된 모든 프레임의 복사본을 가지고 있어야 하며, ACK와 NAK 모두 각각 구별을 해야한다.

* **ACK** : 다음 프레임을 전송 <br> **NAK** : 손상된 프레임 자체 번호를 반환

* 재전송 되는 경우는 다음과 같다.
    - [1] NAK 프레임을 받았을 경우
        - 만약, 수신측으로 0부터 5까지의 데이터를 보내었다고 가정한다.
        - 수신측에서 데이터를 받았음을 확인하는 ACK 프레임을 중간 중간 받게 되며, ACK 프레임을 확인한 전송측은 계속해서 데이터를 전송한다.
        - 그러나 만약 수신측에서 데이터 오류 프레임 2를 발견하고 NAK2를 전송 측에 보낸다.
        - NAK2를 받은 전송측은 데이터 프레임2가 잘못 되었다는 것을 알고 데이터를 재전송한다.
        - GBn ARQ의 특징은 바로 이 데이터를 재전송하는 부분이다.
        - GBn ARQ는 NAK(n)을 받아 데이터를 재전송하게 되면, n데이터만을 재전송하는 것이 아닌, n데이터 이후 데이터를 모두 재전송한다.

    - [2] 전송 데이터 프레임의 분실
        - GBn ARQ의 특징은 확인된 데이터 이후의 모든 데이터 재전송과 수신측의 폐기이다.
        - 수신측에서 데이터 1을 받았는데 갑자기 다음 데이터 3을 받게 된다면 <br> 수신측에서는 데이터 2를 못받았으므로 데이터 3을 폐기하고 NAK2를 전송측에 보낸다.
        - NAK를 받은 전송측은 위의 [1] 경우에서와 같이 NAK(n) 데이터부터 모두 재전송을 실시하며 <br> 수신측은 기존 받았던 데이터 중 NAK(n)으로 보내었던 대상 데이터 이후의 데이터를 모두 폐기하고 재전송 받는다.


    - [3] 지정된 타임아웃내의 ACK 프레임 분실(Lost ACK)
        - 전송스테이션은 분실된 ACK를 다루기 위해, 타이머를 가지고 있다. 
        - 전송측에서는 이 타이머의 타임아웃동안 ACK 데이터를 받지 못했을 경우, 마지막 ACK된 데이터부터 재전송한다.


![](/assets/img/network/error_flow_control_6.png)


![](/assets/img/network/error_flow_control_7.png)


* 전송측은 NAK 프레임을 받았을 경우, NAK 프레임 번호부터 다시 재전송을 시작한다.

* 수신측은 원하는 프레임이 아닐 경우 모두 폐기 처리한다.

* 타임아웃(ACK의 분실)일 경우,  마지막 ACK된 데이터부터 재전송한다.

---

### Selective-Reject(SR) ARQ

* GBn ARQ의 재전송되는 프레임 이후의 모든 프레임을 재전송하는 단점을 개선한 방법이다.

* SR ARQ는 손상된 분실된 프레임만 재전송한다.

* 그렇기 때문에 별도의 데이터 재정렬을 수행해야하며, **별도의 버퍼**를 **필요**로 한다.


---

## GBn ARQ 기법과 SR ARQ의 비교

![](/assets/img/network/error_flow_control_8.png)


![](/assets/img/network/error_flow_control_9.png)




---

## Reference

* [슬라이딩 윈도우, GBn & SR ARQ – 흐름 / 오류 제어 기법](http://wildpup.cafe24.com/archives/469#comments)

* [데이터링크의 흐름제어,혼잡제어,오류제어](http://lelumiere.tistory.com/11)

* [TCP/IP 혼잡제어](http://www.jidum.com/jidums/view.do?jidumId=424)

* [8. Congestion Control - TCP의 혼잡 제어](http://movefast.tistory.com/38)

* [TCP의 흐름제어, 혼잡제어](http://jwprogramming.tistory.com/36)

